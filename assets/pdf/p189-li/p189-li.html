<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta name="generator" content="HTML Tidy for Windows (vers 1st February 2004), see www.w3.org" />
<link rel="stylesheet" href="/www2004.css" type="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<title>A Combined Approach to Checking Web Ontologies</title>
</head>
<body>

<div class="meta">
  <h1 class="title" align="center">A Combined Approach to Checking Web Ontologies</h1>
	<div class="authors">
	  <div class="author">
		<h1 class="author" align="center"><b>Jin Song Dong</b></h1>
		<h2 class="affiliation" align="center">School of Computing<br/>
		National University of Singapore</h2>
		<h3 class="email" align="center">dongjs@comp.nus.edu.sg</h3>
	  </div>
	<div class="author">
		<h1 class="author" align="center"><b>Chew Hung Lee</b></h1>
		<h2 class="affiliation" align="center">DSO National Laboratories<br/>
		Defense Science Organization (DSO)</h2>
		<h3 class="email" align="center">lchewhun@dso.org.sg</h3>
	</div>
	<div class="author">
		<h1 class="author" align="center"><b>Hian Beng Lee</b></h1>
		<h2 class="affiliation" align="center">DSO National Laboratories<br />
		Defense Science Organization (DSO)</h2>
		<h3 class="email" align="center">lhianben@dso.org.sg</h3>
	</div>
	<div class="author">
		<h1 class="author" align="center"><b>Yuan Fang Li</b>
		<a href="#foot1" id="footnote1"><sup>*</sup></a></h1>
		<h2 class="affiliation" align="center">School of Computing<br />
		National University of Singapore</h2>
		<h3 class="email" align="center">liyf@comp.nus.edu.sg</h3>
	</div>
	<div class="author">
		<h1 class="author" align="center"><b>Hai Wang</b></h1>
		<h2 class="affiliation" align="center">Department of Computer Science<br />
		University of Manchester</h2>
		<h3 class="email" align="center">hwang@cs.man.ac.uk</h3>
	</div>
  </div>
  <div class="ACM blurb">
    <p style="line-height: 100%; margin-top: 0; margin-bottom: 2"><font size="2"><br />
    Copyright is held by the author/owner(s).<br />
    <i>
    WWW 2004, </i> May 17&ndash;22, 2004, New York, New York, USA.<br />
    ACM 1-58113-844-X/04/0005.</font><br />
    </p>
  </div>
<div class="abstract">
<h2 class="abstract" style="line-height: 100%; margin-top: 0; margin-bottom: 0">Abstract</h2>
<p class="abstract" style="line-height: 100%; margin-top: 0; margin-bottom: 0">The understanding of
Semantic Web documents is built upon ontologies that define
concepts and relationships of data. Hence, the correctness of
ontologies is vital. Ontology tools such as RACER and FaCT have
been developed to reason ontologies with a high degree of
automation. However, complex ontology-related properties may not be
expressible within the current web ontology languages, consequently
they may not be checkable by RACER and FaCT. We propose to use the
software engineering techniques and tools, i.e., Z/EVES and Alloy
Analyzer, to complement the ontology tools for checking Semantic
Web documents. In this approach, Z/EVES is first applied to remove
trivial syntax and type errors of the ontologies. Next, RACER is
used to identify any ontological inconsistencies, whose origins can
be traced by Alloy Analyzer. Finally Z/EVES is used again to
express complex ontology-related properties and reveal errors
beyond the modeling capabilities of the current web ontology
languages. We have successfully applied this approach to checking
a set of military plan ontologies.</p>
</div>
<div class="keywords, categories &amp; general terms">
<h2 class="keywords" style="line-height: 100%; margin-top: 12; margin-bottom: 0">Categories
&amp; Subject Descriptors</h2>
<p class="keywords" style="line-height: 100%; margin-top: 0; margin-bottom: 0"><span style=
"mso-bidi-font-size: 10.0pt; font-family: Times New Roman; mso-fareast-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA">
D.2.4 [<b>Software Engineering</b>]: Software/Program Verification &ndash; <i>Formal methods, Model checking</i></span></p>
<p class="keywords" style="line-height: 100%; margin-top: 0; margin-bottom: 0"><span style=
"mso-bidi-font-size: 10.0pt; font-family: Times New Roman; mso-fareast-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: AR-SA">
I.2.4 [<b>Knowledge Representation Formalisms and Methods</b>]: Representation languages</span></p>
<h2 class="keywords" style="line-height: 100%; margin-top: 12; margin-bottom: 0">General
Terms</h2>
<p class="keywords" style="line-height: 100%; margin-top: 0; margin-bottom: 0">Languages,
Verification</p>
<h2 class="keywords" style="line-height: 100%; margin-top: 12; margin-bottom: 0">Keywords</h2>
<p class="keywords" style="line-height: 100%; margin-top: 0; margin-bottom: 0">Semantic Web, RACER, Z, Alloy, DAML+OIL, Ontologies</p>
</div>
</div>

<h2 id="introduce">1. Introduction</h2>
<p>Semantic Web gives data well-defined and machine-understandable meaning so
that they can be processed by intelligent software agents on
human's behalf [<a href="#semweb01" id="rsemweb01">2</a>]. Data are expressed in terms of ontologies, which
define their concepts and relationships. Ontology languages such as
DAML+OIL [<a href="#daml01" id="rdaml01">23</a>] and OWL
[<a href="#owl" id="rowl">6</a>] provide basic
vocabularies for describing ontologies. Based on description logic,
ontology languages were originally designed to be decidable
[<a href="#owl03req" id="rowl03req">27</a>] so that agents
can perform reasoning without human guidance. Consistency and
correctness of shared ontologies are vital to the correct
functioning of agents. Hence, ontology checking and verification
tools, such as RACER [<a href="#racermanual" id="rracermanual">11</a>] and
FaCT [<a href="#fact98" id="rfact98">13</a>], etc., have been
developed with the advancement of
ontology languages to facilitate ontology creation, management,
verification, merging, etc. However, some important complex
ontology-related properties cannot be expressed by current ontology
languages and consequently cannot be checked by ontology tools such
as RACER and FaCT. For example, in the military plan ontology, it
is important to ensure that no single military unit is assigned to
two different military tasks (that may be at different locations)
at the same time. Such a property is difficult to be expressed by
DAML+OIL or OWL but validity of such properties is significant.
Hence, the ability of expressing and checking properties beyond the
modeling power of ontology languages is desirable. We propose to
use the software engineering techniques and tools, i.e., Z and
Alloy, to complement the ontology tools for checking Semantic Web
documents.</p>
<p>Z [<a href="#DW:Z96" id="rDW:Z96">24</a>] is a widely used formal
specification language designed to model system data and state. It
is based on ZF set theory and first-order predicate logic, which
can be regarded as a superset of description logic [<a href="#lamb"
id="rlamb">16</a>]. This intrinsic homogeneity implies
that Z is more expressive than ontology languages and can capture
complex constraints beyound current web ontology. Z/EVES [<a
href="#zeves" id="rzeves">20</a>] is an interactive proof
tool for checking and reasoning Z specifications.</p>
<p>Alloy [<a href="#jac02" id="rjac02">14</a>] was
originally developed as a lightweight modeling language aimed at
automated analysis. Its design was influenced by Z but is less
expressive. Alloy Analyzer (AA) [<a href="#alcoa00" id="ralcoa00">15</a>]
is a fully-automated tool for analyzing Alloy specifications with
special model checking features which are helpful to trace the
exact source of errors.</p>
<p>In our previous works, we have applied Z/EVES [<a href="#damlzeves03" id="rdamlzeves03">7</a>]
and AA [<a href="#alloy03" id="ralloy03">8</a>]
separately to reasoning of Web ontologies. We found out that the Z/EVES and AA approaches complement
each other in expressiveness and automation. Moreover, they are also complementary to
Semantic Web reasoners such as RACER. This motivated us to propose this combined approach
to checking Web ontologies using these tools.
</p>
<p>We believe that the quality of Semantic Web documents can be
assured with higher confidence by using the synergy of
reasoning power of RACER, Z/EVES and AA. In our approach, Z/EVES is
first applied to remove trivial syntax and type errors of the
ontologies. Next, RACER is used to identify any ontological
inconsistencies. Then, AA is used as a surgery tool to trace the
origins of such inconsistencies. Finally Z/EVES is used again to
express complex ontology-related properties and reveal errors
beyond the modeling capabilities of the current web ontology
languages. By applying these tools systematically to an ontology,
we can not only uncover more errors than using any one of them
alone, but also correct any inconsistencies more easily and
precisely.</p>
<p>The rest of the paper is organized as follows. We give an overview
of Semantic Web, ontology languages, Z and Alloy and their tool
support in <a href="#overview">Section 2</a>. Z and Alloy semantics
for DAML+OIL are presented in <a href="#semantics">Section 3</a>.
In <a href="#plan">Section 4</a>, we briefly introduce the
respective transformation processes from DAML+OIL to Z and Alloy
and the military plan ontologies, which will be used to illustrate
the approach of checking ontologies in <a href="#approach">Section
5</a>, in which we firstly applied the approach to the plan
ontology itself, where we found an ontological error, and traced
its origin using AA. Secondly, we used the approach to check one
instance ontology. Z/EVES discovered a number of errors beyond the
modeling capabilities of DAML+OIL and Alloy. Finally, <a href=
"#conclude">Section 6</a> concludes the paper.</p>

<h2 id="overview">2. Overview</h2>
<h3>2.1 Semantic Web Languages &amp; Tools</h3>
<p>Semantic Web was originally proposed by Tim Berners-Lee et al. as "an extension
to the current web in which information is given well-defined meaning, better
enabling computers and people to work in cooperation" [<a href="#semweb01">2</a>].
It is a universal medium for exchange of data and uses
metadata to add meaning to data so that they can be understood,
shared, processed and integrated by machines autonomously. In other words,
web contents are not only for human consumption, machines will also be able
to participate. This ability of intelligent agents greatly increases the
power of the web by having machines undertaking works on behalf of human.
The understanding of data is built upon giving data well-defined structure
and meaning, which is accomplished by ontologies.</p>
<p>Ontologies are used to represent concepts and relationships of data on the
web and they are expressed in terms of ontology languages.
The structural well-definedness of these languages comes from XML, cornerstone
of a series of technologies. On top of XML, the Resource Description
Framework (RDF) [<a href="#rdf99" id="rrdf99">18</a>] is a framework for metadata and describes
resources on the web. RDF Schema [<a href="#rdfschema00" id="rrdfschema00">3</a>] provides basic vocabularies
for RDF documents, which are made of a collection of <em>statements</em> of the
form <i>&lt; subject predicate object&gt;</i>, where <em>subject</em> is the resource
we are interested in, <em>predicate</em> specifies the property or characteristic
of the subject and <em>object</em> states the value of the property. RDF Schema
allows structured and semi-structured data to be mixed, which makes data hard
for machines to understand. Moreover, it does not contain all desired modeling
primitives.</p>
<p>DAML (DARPA Agent Markup Language) [<a href="#daml01">23</a>] is built on top of RDF Schema
and it has a much richer set of language constructs to express class and
property relationships than those allowed in RDF Schema. DAML combined effort with the Ontology
Inference Layer (OIL) [<a href="#oil00" id="roil00">4</a>] project and it is now referred to as
DAML+OIL. The other major extension of DAML+OIL is the ability to express
restrictions on class and property definitions. By restricting existing
classes and properties, new concepts can be built incrementally.
This facilitates construction of new ontologies as previous ones can be
reused.</p>
<p>In 2003, based on DAML+OIL, a new ontology language OWL [<a href="#owl03" id="rowl03">26</a>]
was published by W3C. It contains three sublanguages: OWL Lite, DL and Full,
with increasing expressiveness. OWL Lite and DL are decidable whereas OWL
Full is generally not.</p>
<p>Ontology-related tools have been built alongside the development of ontology
languages. The rest of this subsection will introduce a few of these tools.</p>
<p>Cwm (Closed world machine) [<a href="#cwm" id="rcwm">22</a>] is a general-purpose data
processor for the Semantic Web. Implemented in Python and command-line based,
it is also a forward chaining reasoner for RDF.</p>
<p>Triple [<a href="#iswc02:364" id="riswc02:364">21</a>] is a RDF query, inference
and transformation language. It does not have a built-in semantics for
RDF Schema, but it allows semantics of languages to be defined with rules
on top of RDF. This feature of Triple facilitates data aggregation as user
can perform RDF reasoning and transformation under different  semantics.
The Triple tool supports DAML+OIL through external DAML+OIL reasoners such
as FaCT and RACER.</p>
<p>FaCT (<b>Fa</b>st <b>C</b>lassification of <b>T</b>erminologies) [<a
href="#fact98">13</a>], developed at University of Manchester,
is a TBox (concept-level) reasoner that supports automated concept-level
reasoning, namely class subsumption and consistency reasoning.
It does not support ABox (instance-level) reasoning. It is implemented in
Common Lisp and comes with a FaCT server, which can be accessed across
network via its CORBA interface. Given an DAML+OIL ontology, it can classify
the ontology (performs subsumption reasoning) so as to reduce redundancy
and detects any inconsistency within it.</p>
<p>RACER, the <b>R</b>enamed <b>A</b>Box and <b>C</b>oncept
<b>E</b>xpression <b>R</b>easoner [<a href=
"#racermanual">11</a>], implements a TBox and ABox
reasoner for the description logic <img src="pics/p189-li_img1.png"
align="middle" border="0" width="14%" alt="ALCQHIR+(D)-" /> [<a href=
"#haarslev-practical" id="rhaarslev-practical">10</a>]. It can be regarded as (a) a Semantic
Web inference engine, (b) a description logic reasoning system
capable of both TBox and ABox reasoning and (c) a prover for modal
logic Km. In the Semantic Web domain, RACER's functionalities
include developing ontologies (creating, maintaining and deleting
concepts, roles and individuals); querying, retrieving and
evaluating the knowledge base, etc. It supports DAML+OIL and
RDF.</p>
<p>We chose RACER as the ontology reasoner for our approach since
it has a richer set of functionalities and ontology editors such as
OilEd [<a href="#oiled" id="roiled">1</a>] and RICE
(Racer Interactive Client Environment), both of which can perform
reasoning over DAML+OIL with RACER as a background reasoner. In our
approach, RACER will be used with OilEd as a user interface.</p>

<h3>2.2 Z &amp; Alloy: Languages &amp; Tools</h3>
<p>Z [<a href="#DW:Z96">24</a>] is a formalism based on ZF set theory and first-order
predicate logic. It is specially suited to model system data and state.
Z/EVES [<a href="#zeves">20</a>] is an interactive system
for composing, checking, and analyzing Z specifications.
It supports the analysis of Z specifications in a number
of ways: syntax and type checking, schema expansion, precondition calculation,
domain checking, general theorem proving, etc. In Z/EVES, Z specifications
are in the form of <em>sections</em> to improve reuse. The built-in section
<tt>toolkit</tt> defines basic constants and operators. Specifications are
built hierarchically by including existing sections as their parents.</p>
<p>Alloy [<a href="#jac02">14</a>] is a structural modeling language emphasizing on automated reasoning
support. It treats relations as first class citizens and uses relational
composition as a powerful operator to combine various structural entities.
The design of Alloy was influenced by Z and it can be (roughly) viewed as a subset
of Z. AA is a constraint solver that provides fully automatic
simulation and checking. AA works as a compiler: it compiles a given problem
into a (usually huge) boolean formula, which is subequently solved by a SAT solver,
and the solution is then translated back to AA. Inevitably, a scope - a bound on the size of
the domains - must be given to make the problem finite.</p>
<p>AA determines whether there exists a model of the formula.
When AA finds an assertion to be false, it generates a counterexample, which
(in some cases) makes tracing the error easier, compared to theorem provers.
However, the capability of AA is constrained by the way it works. Since AA
performs exhaustive search, it does not scale very well. In our experiences,
AA can only handle ontologies with no more than twenty entities.
Similar to Z/EVES, Alloy specifications are in the form of <em>modules</em>,
organized into a tree. Existing modules can be reused by commands
<tt>open</tt> or <tt>use</tt>.</p>
<p>The aim of our approach is to ensure the absence of ontological inconsistencies
and correctness of ontology-related properties to the maximal extend. Hence, to be
on the safe side, we assume that the knowledge base (ontology) under investigation
contains all relevant facts (Closed World Assumption). The bound on Alloy modules
does not cause semantic problems as AA is only used as a surgery tool to locate the
sources of identified errors.</p>

<h2 id="semantics">3. Z &amp; Alloy Semantics for DAML+OIL</h2>
<p>In this Section, we present a subset of Z &amp; Alloy semantics
for the ontology language DAML+OIL. The full semantics can be found
in [<a href="#damlzeves03">7</a>] and [<a href="#alloy03">8</a>]. In this Section,
the Z definitions will be presented above the corresponding Alloy
definitions, which will be in <tt>teletype font</tt>.</p>

<h3>3.1 Z/Alloy Semantics for DAML+OIL</h3>

<h4>Basic Concepts</h4>
<p class="noindent">Everything in Semantic Web is a <tt>Resource</tt>. So we model it
as a given type in Z and Alloy.</p>
<blockquote>
<img src="pics/p189-li_img0.png" width="10%" alt="resource" />
<pre>
<tt>sig Resource {}</tt>
</pre></blockquote>

<p><tt>Class</tt> corresponds to a concept, which has a number of
resources associated with it: the <tt>instances</tt> of this class.
Hence, in Z, we model class as a subset of resource and instances
as a function from a class to a set of resources. In Alloy, each
class maps a set of resources via the relation <tt>instances</tt>,
which contains all the instance resources. The Alloy keyword
<tt>disj</tt> is used to indicate that class and property are
disjoint.</p>
<blockquote>
<img src="pics/p189-li_img2.png" width="30%" alt="class &amp; instances" />
<pre>
<tt>disj sig Class extends Resource
    instances: set Resource</tt>
</pre></blockquote>

<p><tt>Property</tt> is also a subset of resource, disjoint with
class. A property relates resources to resources. The function
<tt>sub_val</tt> maps each property to the resources it
relates.</p>
<blockquote>
<img src="pics/p189-li_img3.png" width="50%" alt="property &amp; sub_val" />
<pre>
<tt>disj sig Property extends Resource
    sub_val: Resource -&gt; Resource</tt>
</pre></blockquote>

<h4>Class relationships</h4>
<p class="noindent">The property <tt>subClassOf</tt> is defined as a relation from
class to class. For a class <i>c<sub>1</sub></i> to be the sub
class of class <i>c<sub>2</sub></i>, the instances of
<i>c<sub>1</sub></i> must be a subset of instances of
<i>c<sub>2</sub></i>. Other properties such as
<tt>disjointWith</tt> are similarly defined. Note that the subset
relationship is expressed in terms of membership relationship to
make proof in Z/EVES more automated. In Alloy, a function is used
to represent the subClassOf concept.</p>
<blockquote>
<img src="pics/p189-li_img4.png" width="54%" alt="subClassof &amp; disjointWith" />
<pre>
<tt>fun subClassOf(c1, c2: Class)
    c2.instances in c1.instances}
fun disjointWith (c1, c2: Class)
    no c1.instances &amp; c2.instances</tt>
</pre></blockquote>

<h4>Class &amp; Property</h4>
<p class="noindent">The property <tt>toClass</tt> attempts to establish a maximal
possible set of resources as a class. In Z context, it states that
any resource <i>a<sub>1</sub></i> is an instance of class
<i>c<sub>1</sub></i> if either: <i>a<sub>1</sub></i> is defined for
property <i>p</i> and <i>(a<sub>1</sub>,a<sub>2</sub>) <font face=
"Symbol">&Icirc;</font> sub_val(p)</i> implies that
<i>a<sub>2</sub></i> is an instance of class <i>c<sub>2</sub></i>;
or that <i>a<sub>1</sub></i> is not defined for <i>p</i> at
all.</p>
<blockquote>
<img src="pics/p189-li_img5.png" width="45%" alt="toClass" />
<pre>
<tt>
fun toClass (p:Property, c1:Class, c2:Class)
    all a1, a2: Resource | a1 in c1.instances &lt;=&gt;
    a2 in a1.(p.sub_val) =&gt; a2 in c2.instances</tt>
</pre></blockquote>

<p>Property <tt>hasValue</tt> states that all instances of class
<i>c</i> have resource <i>r</i> for property <i>p</i>.</p>
<blockquote>
<img src="pics/p189-li_img6.png" width="40%" alt="hasValue" />
<pre>
<tt>fun hasValue (p:Property, c:Class, r:Resource)
    {all a:Resource |
    a in c.instances =&gt; a.(p.sub_val) = r}</tt>
</pre></blockquote>

<h4>Property relationships</h4>
<p class="noindent">In Z context, the property <tt>subPropertyOf</tt> states that a
property <i>p<sub>1</sub></i> is a sub property of another property
<i>p<sub>2</sub></i> iff <i>sub_val(p<sub>1</sub>)</i> is a subset
of <i>sub_val(p<sub>2</sub>)</i>.</p>
<blockquote>
<img src="pics/p189-li_img7.png" width="40%" alt="subPropertyOf" />
<pre>
<tt>fun subPropertyOf (p1, p2:Property)
    {p1.sub_val in p2.sub_val</tt>
</pre></blockquote>

<h3>3.2 Import Mechanisms &amp; Proof Support</h3>
<p>The Z semantics is contained in a section <tt>daml2z</tt>,
on top of <tt>toolkit</tt>. Definitions alone are not sufficient to
exploit the full power of Z/EVES. An ample stock of rewrite rules,
forward rules and assumption rules is needed to make proof processes
more automated. Based on the semantic model, we constructed
a section, called <tt>DAML2ZRules</tt>, of rules which describes the
above definitions in more than one angle and is used to help Z/EVES to
perform reasoning tasks. This section has <tt>daml2z</tt> as parent.
The Alloy semantics is contained in a module called <tt>DAML</tt>.</p>
<p>Ontologies are built layer on layer. Other domain specific ontologies
are built in terms of basic concepts presented in this section and
their corresponding Z models will have <tt>DAML2ZRules</tt> or its
descendent sections as parents. Similarly, the Alloy models will import
module <tt>damloil</tt> or its descendents.</p>

<h2 id="plan">4. Military Plan Ontologies &amp; Transformation</h2>
<h3>4.1 Military Plan Ontologies</h3>
<p>DSO National Laboratories (DSO) developed a DAML+OIL military
plan ontology [<a href="#dso02" id="rdso02">17</a>],
defining concepts in the military domain, including military
organizations, specialities, geographic features, etc. For example,
the class <tt>MilitaryTask</tt> is defined as follows. It is a sub
class of <tt>MilitaryProcess</tt>,</p>
<pre>
<tt>&lt;daml:Class rdf:about="http://www.dso.org.sg/
   PlanOntology#MilitaryTask"&gt;
  &lt;rdfs:label&gt;MilitaryTask&lt;/rdfs:label&gt;
  &lt;rdfs:subClassOf&gt;
    &lt;daml:Class rdf:about="http://www.dso.org.sg/
      PlanOntology#MilitaryProcess"/&gt;
  &lt;/rdfs:subClassOf&gt;
&lt;/daml:Class&gt;
</tt>
</pre>

<p>A number of plan instances of this ontology were also generated from
plain text by an information extraction (IE) engine developed by DSO.
Military plans are typically prepared as both graphical overlays
and textual documents detailing the plans. IE is used to transform
the textual documents into ontological data.
A typical IE workflow consists of word segmentation &amp; stemming,
PoS (part of speech) tagging, Named Entity
recognition, etc. With all information gathered from various steps,
the IE engine then fills the slots in pre-defined templates, which
is subsequently transformed into a RDF document,
which usually comprises the following four parts:</p>

<ul>
<li>A set of military operations and tasks, defining their types,
phases and the logic order.</li>
<li>A set of military units, which are the participants of the
military operations and tasks,</li>
<li>A set of geographic locations, where such operations take place
and</li>
<li>A set of time points for constraining the timing of such
operations.</li>
</ul>

<h3>4.2 Web Ontology to Z</h3>
<p>We have developed a tool in Java to automatically transform
ontologies into Z. Given a DAML+OIL or RDF ontology, it iterates
through all elements and transforms them into Z definitions.</p>
<p>We used this tool to transform the military plan ontology into Z
section <tt>military</tt>, with <tt>DAML2ZRules</tt> as parent. To
better utilize Z/EVES's proof power, We made the following
enhancements to the <tt>military</tt> section:</p>

<ul>
<li>During transformation, <em>labels</em> are systematically added
to Z predicates, making them axioms (either rewrite rules or
assumption rules) recognized by Z/EVES, which will assume an
assumption rule to be true and rewrite the left-hand side of a
rewrite rule to its right-hand side during the proof process.</li>
<li>Since MilitaryProcess and its sub classes have a start and end
time, <tt>start</tt> and <tt>end</tt> are modeled as functions from
MilitaryProcess to integer, so that Z/EVES can perform reasoning
over integer domain.</li>
<li>A set of theorems specific to these military definitions are
formulated. These theorems describe the relationships among the
various military entities. For example, we have theorems stating
sub task relationship between different kinds of military tasks,
transitivity of sub task relationship, etc.</li>
</ul>
<p>For example, the class MilitaryTask presented earlier is
transformed into the following axiomatic definition. Note that the
predicate is marked as an assumption rule.</p>
<blockquote>
<img src="pics/p189-li_img8.png" width="45%" alt="MilitaryTask" />
</blockquote>

<p>Our tool also transforms instance RDF ontologies into Z
specifications, in which additional Z predicates are sometimes
added to make the reasoning process of Z/EVES more automated.</p>
<p>In DAML+OIL, different names refer to different entities (Unique
Name Assumption [<a href="#racermanual">11</a>]). However, in Z, different names can refer to the
same entity. We use cardinality of sets to make Z/EVES work the
same way. In the instance ontology, whenever two military tasks are
related by sub task or super task relationship, we construct a set
containing the two tasks and assume the cardinality of the set is
two, as follows:</p>
<blockquote>
<img src="pics/p189-li_img9.png" width="40%" alt="cardinality" />
</blockquote>

<h3>4.3 Web Ontology to Alloy</h3>
<p>The transformation from DAML+OIL &amp; RDF ontologies to Alloy
is straightforward. We developed an XSLT [<a href=
"#xslt" id="rxslt">25</a>] stylesheet for automatic transformation.
The military ontology is transformed into a module <tt>military</tt>.
The class MilitaryTask is transformed into the following Alloy
definition:</p>
<blockquote><tt>static disj sig MilitaryTask extends Class {}<br />
fact{subClass(MilitaryProcess, MilitaryTask)</tt></blockquote>

<h2 id="approach">5. Combined Approach to Checking Ontologies</h2>
<h3 id="approach-details">5.1 Combined Approach</h3>
<p>In this Section, we present the approach of checking DAML+OIL ontologies
using tools RACER, Z/EVES and AA in conjunction. Given an ontology, we apply
the tools in the following steps:</p>
<ol>
<li>
We transform it to a Z specification and use Z/EVES as a type
checker to check for syntax and type errors. Any such error found by
Z/EVES will be corrected in the original ontology. Z/EVES performs the
type checking automatically.
<p class="noindent">The purpose of this step is to remove trivial errors before actual checkings
are performed. Sometimes, type errors are caused by implicit facts in the ontology.
Unlike ontology languages that use the "Open World Assumption", specification
languages like Z usually do not <em>automatically</em> assume an implicit fact to be true.</p>
<p class="noindent">For example, in the instance ontology planA.daml, the resource <tt>ECA-P2-P7</tt>
is an instance of class <tt>Thing</tt>. However, it is defined for the property <tt>start</tt>,
whose <tt>domain</tt> is instances of class <tt>MilitaryProcess</tt> and its sub classes.
If RACER is queried whether <tt>ECA-P2-P7</tt>
is an instance of <tt>MilitaryProcess</tt>, it will return true and hence this fact is implicit
and assumed. However, if similar query is issued to Z/EVES, it will complain that
<tt>ECA-P2-P7</tt> is not well typed. The revelation of implicit facts helps human to understand
the ontology better.</p>
</li>

<li>
We input the trivial-errors-corrected ontology into OilEd and connect to RACER
to <em>classify</em> it. In this step, RACER will perform unsatisfiability, subsumption
and instance checking, which will decide whether there are ontological inconsistencies
fully automatically.
<p class="noindent">RACER will report any inconsistent classes and properties, however, it is unable to
tell where the error lies.
OilEd as an ontology editor collects information related to each individual class and property
and the information about the inconsistent entity will be used in the next step to identify
possible source of the inconsistency.</p>
</li>

<li>
In case of an error,
as described in the previous step, OilEd will return a minimal set of classes,
properties and instances that constrain the offending concept.
Then we employ AA to analyze the isolated
ontology fragment to determine the source of the error. In some cases, AA can
pinpoint certain classes and properties which cause the error.
<p class="noindent">If AA does not detect an error, we need to iteratively augment the fragment ontology
by referring to OilEd and including classes, properties and instances related
to existing definitions. This step requires human interaction but it can be handled
with relative ease.</p>
<p class="noindent">If the fragment ontology is too large for AA to analyze, we use Z/EVES
as a theorem prover to determine the source of the inconsistency, which
requires substantial expertise in interacting with Z/EVES.</p>
<p class="noindent">After an error is reported, we check back the original ontology and correct
it accordingly. RACER is used again to check the consistency of corrected ontology.</p>
</li>

<li>
Finally, we use Z/EVES again to check properties beyond the modeling capability
of DAML+OIL and Alloy. As stated in <a href="#introduce">Section 1</a>, Z is a superset
of ontology languages and Alloy and it can capture a richer set of information, which
is sometimes crucial to the correctness of the ontology. This final step applies
to instance ontologies in particular.
<p class="noindent">This step is domain-specific and it requires thorough understanding of the domain.
For the military plan ontologies case study, we have constructed a set of theorems
in Z/EVES and used them to systematically test the correctness of the instance.</p>
<p class="noindent">By capturing properties that cannot be expressed by DAMO+OIL using Z, we actually
treat Z as an ontology language but with increased expressiveness, at the cost of
decidability and automation. The benefit of the gained expressiveness is domain-specific
and it will be exemplified in our case study in <a href="#check-instance">Section 5.3</a>.</p>
</li>
</ol>
<p>In the rest of this Section, we will use the military plan
ontologies case study to demonstrate this approach.</p>

<h3>5.2 Checking Military Plan Ontology</h3>
<p>As introduced in <a href="#plan">Section 4</a>, the military
plan ontology defines concepts in the military domain. It contains
98 classes, 26 properties and 34 resources.</p>
<p><b>Firstly</b>, we transformed this ontology into the
corresponding Z section <tt>military</tt>. With order of some Z
definitions changed, Z/EVES accepts this Z section without
complaints, which means, the section does not contain trivial
errors such as syntactic and type errors. The absence of trivial
errors is because this ontology is written by hand, not produced by
the IE engine.</p>
<p><b>Secondly</b>, we open OilEd and connect it to RACER via HTTP
interface. We then load the ontology into OilEd and classify it, as
described in step 2 of <a href="#approach-details">Section
5.1</a>.</p>
<p>Shown in <a href="#oiled-unsat">Figure 1</a>,
<tt>PrepareDemolition-MilitaryTask</tt>, the first class on the
left panel, is highlighted by OilEd as an inconsistent class.
Restrictions imposed on this class are displayed at the bottom on
the right.</p>
<div class="image">
<p class="imgage" id="oiled-unsat"><img src="p189-li_fig1.jpg"
width="60%" align="middle" alt="oiled inconsistent class" /></p>
<p class="caption"><b>Figure 1. Discovery of an unsatisfiable
concept by RACER</b></p>
</div>

<p>RACER tells us that the class PrepareDemolition-MilitaryTask
causes the problem. However, it cannot determine exactly where the
inconsistency comes from. In the next step, we employ AA to
pinpoint the source of the inconsistency.</p>
<p><b>Thirdly</b>, we extract a small ontology fragment containing definitions
of the offending class and those classes, properties and instances appearing in
the <b>Restrictions</b> panel, namely <tt>assignedTo</tt>,
<tt>EngineerUnit</tt> and <tt>ArtilleryFiringUnit</tt>.
This fragment is subsequently transformed into an Alloy module shown in <a href="#alloy_spec">Figure
2</a>, which is loaded into AA to check for inconsistency.
Note that the last fact in the Alloy module
denotes that there exists some instances of class <tt>EngineerUnit</tt> which
have been <tt>assignedTo</tt> some tasks. This fact is necessary because of the
definition of <tt>toClass</tt>, which establishes a maximum possible set of resources
as a class.</p>

<div class="image">
<p class="image" id="alloy_spec"> </p>
<pre>
<tt>
module inconsistency_military
open demo1/library/DAML

static disj sig MilitaryTask extends Class {}
static disj sig PrepareDemolition_MilitaryTask
  extends Class {}
fact {subClassOf
  (MilitaryTask, PrepareDemolition_MilitaryTask)}
static disj sig assignedTo extends Property {}
static disj sig ModernMilitaryUnit extends Class{}
static disj sig EngineerUnit, ArtilleryFiringUnit
  extends Class{}
fact {subClassOf(ModernMilitaryUnit, ArtilleryFiringUnit)}
fact {subClassOf(ModernMilitaryUnit, EngineerUnit)}
static disj sig EngineeringMilitarySpeciality
  extends Resource {}
static disj sig speciality extends Property {}
fact{hasValue (speciality,
  EngineerUnit, EngineeringMilitarySpeciality)}

fact {disjoinWith(ArtilleryFiringUnit, EngineerUnit)}
fact {toClass(assignedTo,
  PrepareDemolition_MilitaryTask, ArtilleryFiringUnit)}
fact {toClass(assignedTo,
  PrepareDemolition_MilitaryTask, EngineerUnit)}
fact {some
  (assignedTo.sub_val).(EngineerUnit.instances)}

fun dummy() {}
run dummy for 15
</tt></pre>
<p class="caption"><b>Figure 2. Alloy Concepts related to the
inconsistency</b></p>
</div>

<p>AA detects the inconsistency by its inability of finding a <em>solution</em>
that satisfies all facts within the given scope.
However, no solution may be due to the scope being too small. To determine
the reason behind, we use AA's utility "Determine unsat core" to trace
the source of the error. If we are un-convinced of the error, we may
increase the scope and run AA again.</p>
<p><a href="#unsat_core">Figure 3</a> shows how AA
determines which facts caused the problem. In the right panel,
clauses <tt>_Fact_144</tt> to <tt>_Fact_147</tt> are related to the problem.
Arrows were added in the figure to show the correspondence of clauses in the
right panel and concepts in the left panel. After examining the clauses,
we found that the 4 clauses with arrows attached actually caused the problem.
Hence, the lack of solution was indeed due to the inconsistency of the original
ontology. The inconsistency is caused by assigning
<tt>PrepareDemolition_MilitaryTask</tt> to both
<tt>ArtilleryFiringUnit</tt> and <tt>EngineerUnit</tt>, which are
<tt>disjointWith</tt> each other. Hence, by removing any
of the two assignments, the fact of disjointness  or the fact that some instances
of <tt>EngineerUnit</tt> being assigned, the inconsistency can be eliminated.
Since the source of the inconsistency is discovered by AA, we need not resort to
Z/EVES, in this case.</p>

<div class="image">
<p class="imgage" id="unsat_core"><img src="p189-li_fig2.jpg"
width="80%" align="middle" alt="Alloy unsat core" /></p>
<p class="caption"><b>Figure 3. AA showing the source of
unsatisfiability</b></p>
</div>
<p>After checking the original ontology, we found that
<tt>ArtilleryFiringUnit</tt> was mistakenly assigned to
<tt>PrepareDemolition_MilitaryTask</tt>. After this
fact is removed, RACER confirms that the ontology is satisfiable.</p>
<p><b>Lastly</b>, we will use Z/EVES to check for more complex properties.
Since this is not an instance ontology, the <i>4<sup>th</sup></i> step
is not performed. It will be detailed in the next subsection,
where we will check the correctness of an instance plan ontology.</p>

<h3 id="check-instance">5.3 Checking Instance Ontology</h3>
<p>In this subsection, we discuss how Z/EVES is used to check an instance of the
military plan ontology: planA.daml, to illustrate the final step of the
approach.</p>
<p>To ensure the correctness of military plan ontologies, it is not enough just to
perform checking using AA and RACER. We need to ensure,
for example, that no military unit is assigned to two or more military tasks at
the same time, and that no military task is a sub task of itself.
By performing the last step of the approach, we discovered a number of
such errors beyond the modeling capabilities of DAML+OIL and Alloy.</p>
<p>The first three steps are not shown to concentrate on the final step of our approach.
In the first three steps, we performed the usual transformation and checking and
obtained an ontological-error-free document. It was then transformed into
a Z section. Part of this ontology and the corresponding Z definitions are
shown below.</p>

<pre>
<tt>
&lt;rdf:Description rdf:about='ECA-P1-P2-P2-S1'&gt;
  &lt;NS4:subTaskOf rdf:resource='ECA-P1-P2'/&gt;
  &lt;NS4:subTaskOf rdf:resource='ECA-P1-P2-P2'/&gt;
  &lt;NS4:location rdf:resource='E. AFRICA'/&gt;
  &lt;NS4:target rdf:resource='E. AFRICA'/&gt;
  &lt;rdf:type rdf:resource='http://www.dso.org.sg/
     PlanOntology#HastyDefend-MilitaryTask'/&gt;
  &lt;NS0:start rdf:resource='0'/&gt;
  &lt;NS0:end rdf:resource='15'/&gt;
  &lt;NS4:assignedTo rdf:resource='InfantryBattalion_aa5'/&gt;
&lt;/rdf:Description&gt;
&lt;rdf:Description rdf:about='G. SMILAX'&gt;
  &lt;rdf:type rdf:resource='http://www.dso.org.sg/
     PlanOntology#AxisOfAdvance'/&gt;
&lt;/rdf:Description&gt;
&lt;rdf:Description rdf:about='InfantryBattalion_aa5'&gt;
  &lt;rdf:type rdf:resource='http://www.dso.org.sg/
     PlanOntology#InfantryBattalion'/&gt;
&lt;/rdf:Description&gt;
</tt>
</pre>
<blockquote>
<img src="pics/p189-li_img10.png" width="44%" alt="ECA-P1-P2-P2-S1" /><br /><br />
<img src="pics/p189-li_img11.png" width="33%" alt="G. SMILAX" /><br /><br />
<img src="pics/p189-li_img12.png" width="43%" alt="InfantryBattalion_aa5" /><br /><br />
<img src="pics/p189-li_img13.png" width="41%" alt="rule ECA-P1-P2-P2-S1_subTaskOf" /><br /><br />
<br />
</blockquote>

<p>It may be noted that the <tt>subTaskOf</tt> statement is modeled in
a separate Z predicate at the end. Actually all <tt>subTaskOf</tt> statement are
extracted and put to the end of the Z specification to prevent circular or advance
reference of military tasks.</p>
<p>The instance ontology planA.daml contains altogether 954 statements, describing 195 resources
(RDF subjects). Among these 195 subjects, 78 are instances of <tt>MilitaryProcess</tt> and sub
classes; 69 are instances of <tt>ModernMilitaryUnit</tt> and sub classes and the rest 48
are instances of <tt>GeographicArea</tt> and sub classes.</p>
<p>The transformed Z section contains 791 predicates specifying 195 Z (axiomatic) definitions.
Note that there is a decrease in number of Z predicates from that of RDF statements. There are
two reasons: (1) statements with properties <tt>comment</tt> and <tt>label</tt> are not transformed to Z since
they are just descriptions of the subject; (2) statements such as <tt>subTaskOf</tt> and
<tt>assignedTo</tt> for any one instance are grouped to form one Z predicate, as shown in
the above rewrite rule <tt>ECA_P1_P2_P2_S1_subTaskOf</tt>.</p>
<p>Twenty-eight type errors were discovered by Z/EVES in step 1. Most of these errors
are caused by the inaccuracy of the IE engine. For example,
<tt>Coastal_Hook_Force</tt> was defined as a class in the plan ontology;
it is redefined as a resource of type <tt>Thing</tt> in this instance ontology.
Although the user may have wanted to redefine <tt>Coastal_Hook_Force</tt> as <tt>Thing</tt>,
it is very unlikely since no semantic significance is added and the ontology becomes
harder to comprehend. Conservatively, we treat this redefinition as an error.</p>
<p>In step 1, implicit facts are also made explicit by Z/EVES. For example,
the type of one of the military tasks <tt>ECA-P1-P4-P1</tt> was <tt>Thing</tt> in
the instance ontology, it is reported by Z/EVES as a type error and corrected
to be <tt>MilitaryProcess</tt>. The reason is that <tt>ECA-P1-P4-P1</tt> has
<tt>start</tt> and <tt>end</tt> time points associated with it. And the domains
of these two functions are restricted to instances of <tt>MilitaryProcess</tt>.</p>
<p>Note that in ontological sense, the above errors are not treated as inconsistencies:
in description logics, implicit information can be derived and if there
is no conflict, it is assumed true. Hence, RACER will return true if it is queried
whether <tt>ECA-P1-P4-P1</tt> is an instance of <tt>MilitaryProcess</tt>.
However, Z/EVES is more restrictive in treating types of Z language constructs.</p>
<p>After the first three steps were performed, no ontological errors were found.
We proceed to the <i>4<sup>th</sup></i> step. Before applying Z/EVES, we studied the
plan ontology and gained some insights of military domain, based on which
we formulated a number of theorems to test the correctness of instance ontologies.
One such theorem tests that for a given <tt>MilitaryTask</tt>, its start time
is less than end time and it is not a sub task of itself.</p>

<blockquote>
<img src="pics/p189-li_img14.png" width="38%" alt="MilitaryTaskTimeSubTaskTest1" />
</blockquote>

<p>14 such <em>hidden errors</em> are discovered. 2 of them
are caused by military tasks having start time greater than end time; 4
are caused by military tasks do not have end time defined, 3 are
caused by military units being assigned to different tasks simultaneously
and 5 are caused by military tasks having more than one <tt>start</tt> or <tt>end</tt> time points.
In the rest of this subsection, we show how various kinds of checkings can be
performed by Z/EVES through some examples.</p>
<p>We systematically test all instances of military tasks (including sub classes)
for the above theorem. For example, one such instance,
<tt>ECA_P1_P2_P1_S1</tt>, is tested as follows. It is an instance of class
<tt>HastyDefend_MilitaryTask</tt> and it has two super tasks:
<tt>ECA_P1_P2</tt> and <tt>ECA_P1_P2_P1</tt>.</p>
<blockquote>
<img src="pics/p189-li_img15.png" width="50%" alt="proof script of MilitaryTaskTimeSubTaskTest1" />
</blockquote>

<p>The proof process is intuitive: we consider the super tasks
of <i>x</i> (instantiated to <tt>ECA_P1_P2_P1_S1</tt> in this case)
one at a time. When all sub goals are completed,
the current goal is proven. Defined in the built-in section <tt>toolkit</tt>,
the rule <i>cardCup</i> is used here, with <tt>Resource</tt> as the actual
parameter, to make the two military tasks distinct, as we stated in
the end of <a href="#plan">Section 4</a>.The last command <tt>reduce</tt> returns
<tt>true</tt>, which means that the <em>current</em> goal is proven, not the whole
theorem.</p>
<p>We test another military task: <tt>ECA_P3_P3_S1</tt>. This time,
after issuing similar commands, the remaining goal is of the form:</p>
<blockquote>
<img src="pics/p189-li_img16.png" width="24%" alt="remaining goal" />
</blockquote>
<p>This is an apparent contradiction to the <i>2<sup>nd</sup></i> step of the proof:
instantiation of <i>x</i> to <tt>ECA_P3_P3_S1</tt>.
Hence we know for sure there is something wrong with this instance.
Since it is very hard for theorem provers to prove falsity, we need to
negate the theorem and show that the negated theorem can be proved to
be <tt>true</tt>.</p>

<blockquote>
<img src="pics/p189-li_img17.png" width="43%" alt="negated theorem" />
</blockquote>

<p>By negating the theorem and trying again, Z/EVES does return <tt>true</tt>.
After checking the ontology, we found that start time is 7 but end
time is 4, hence it is indeed an error, which was not discovered by RACER and AA.</p>
<p>After performing this checking to all military tasks, 2 such errors were found.
These errors may be caused by the inaccuracy of the IE engine;
or they may be human error. After checking with the developers
at DSO, it was found out that the errors were in the original textual document, which
is the input of the IE engine. Hence in this case, it is human factor that is not
reliable.</p>
<p>The discovery of this kind of errors motivated us to perform some more complex reasoning.
Since we have ensured that all instances of <tt>MilitaryTask</tt> (and sub classes) are <em>locally</em>
correct, naturally we want to express and check the inter-task temporal relationship.
For example, the following theorem states that for any instance <i>x</i> of <tt>MilitaryTask</tt>
and a set <i>y</i> of super tasks of <i>x</i>, any member <i>z</i> of set <i>y</i> must satisfy
<i>start(z) <font face="Symbol">&pound;</font> start(x) <font face="Symbol">&#217;</font> end(z) <font face="Symbol">&#179;</font> end(x)</i>. That means, the start time of a super task
must be less than or equal to that of its sub task, and the end time of a super task must be
greater than or equal to that of its sub task. Since we have ensured that start time is before
the end time for each military task, the above predicate suffices to prove the correctness.</p>

<blockquote>
<img src="pics/p189-li_img37.png" width="41%" alt="subTaskOfTimingTest2" />
</blockquote>

<p>The following proof scripts test the above theorem against the instance
<tt>ECA_P1_P1_P1_S1</tt> and its 2 super tasks, Z/EVES confirms the temporal
relationship of these instances is correct by returning <tt>true</tt>.</p>

<blockquote>
<img src="pics/p189-li_img38.png" width="45%" alt="proof script of subTaskOfTimingTest2" />
</blockquote>

<p>The last theorem we present in this paper, <tt>MilitaryUnitTest</tt>,
states that for any given military unit and two
military tasks assigned to this unit, the durations of the two tasks do not overlap.
As we have proved the <em>local</em> consistency of each military task,
the predicate <i>end(y) <font face="Symbol">&pound;</font> start(z) <font face=
"Symbol">&Uacute;</font> end(z) <font face="Symbol">&pound;</font>
start(y)</i> is sufficient.</p>

<blockquote>
<img src="pics/p189-li_img18.png" width="43%" alt="MilitaryUnitTest" />
</blockquote>

<p>We exhaustively and systematically apply this theorem to appropriate military units and tasks.
During transformation process, we have collected information about what tasks
each military unit executes; it is easy to proceed in this case.
The proof process of one such combination is shown below.</p>
<blockquote>
<img src="pics/p189-li_img19.png" width="29%" alt="proof script of MilitaryUnitTest" />
</blockquote>

<p>After the last command <tt>reduce</tt> is entered, the following remaining
goal is returned by Z/EVES:</p>
<blockquote>
<img src="pics/p189-li_img20.png" width="45%" alt="remaining goal" />
</blockquote>

<p>This is an abvious contradiction to the instantiation of quantified variables
<i>x</i>, <i>y</i> and <i>z</i>. Hence we suspect that there is an error with this combination
of instances. So we negate the theorem again and try to prove this negated theorem.</p>
<blockquote>
<img src="pics/p189-li_img21.png" width="46%" alt="negated theorem again" />
</blockquote>

<p>After issuing similar commands, we proved the negated theorem.
We found in the original ontology that the start and end time of
these two military tasks are the same. Hence there is indeed an error
that cannot be discovered by RACER and AA.</p>

<h2 id="conclude">6. Conclusion</h2>
<p>In our attempts to answering the emerging needs of checking and
validating web ontologies, we propose an approach of checking
correctness of DAML+OIL ontologies using a combination of tools
from both Semantic Web (RACER) and Software Engineering (Alloy
Analyzer and Z/EVES).</p>
<p>For checking Semantic Web documents, our general approach begins
with using Z/EVES to check for trivial errors such as syntax and
type errors, which are corrected in the original ontology. Next,
RACER is used to automatically determine the consistency of the
ontology. Thirdly, if the ontology is inconsistent, we identify a
small partition of concepts in the ontology closely-related to the
offending concept(s) and use AA as a surgery tool to check for the
source of the inconsistency. If AA is unable to find the error, we
may need to use Z/EVES's theorem-proving power to interactively
check for the error. Lastly, for instance ontologies, we use Z/EVES
again as a theorem prover to check for properties that ontology
languages and Alloy cannot model.</p>
<p>We have applied our approach to a recent real-world case study
of military plan ontologies. In the plan ontology, we discovered
one ontological inconsistency and traced its origin using AA. Using
Z/EVES, we discovered 14 errors in one instance ontology. These
errors are beyond the modeling capabilities of DAML+OIL and Alloy
and cannot be detected by RACER and AA.</p>
<p>Although we have worked carefully to ensure the correctness of the Z/Alloy semantics
for DAML+OIL, it is necessary to formally prove the soundness of the semantics. Its proof using
institutions theory [<a href="#goguen92" id="rgoguen92">9</a>]
is part of the future work that is underway.</p>
<p>In this paper, we have concentrated on expressing and checking static properties of
DAML+OIL ontologies, capturing and checking dynamic properties such as those defined
by Semantic Web services [<a href="#daml-s" id="rdaml-s">5</a>] using formalisms such as Z,
PVS [<a href="#PVS-CADE92" id="rPVS-CADE92">19</a>]
or CSP [<a href="#hoare:csp" id="rhoare:csp">12</a>] will be one of the future work.</p>

<h2>7. Acknowledgement</h2>
<p>The authors wish to thank Chan Kum Lan, Chew Lock Pin and
How Khee Yin for their collaboration and support. We are also
grateful to anonymous referees for their valuable comments. This
work is partially supported by the Defense Innovative Research
Project (DIRP) research grant "Formal Design Methods and DAML".</p>

<div class="references">
<h2>8. References</h2>
<p class="ref noindent" id="oiled">[<a href="#roiled">1</a>] S. Bechhofer, I. Horrocks, C. Goble, and R. Stevens. <span class="title">OilEd: a
reason-able ontology editor for the semantic web.</span> <span class="details">In <i>Proceedings of KI2001, Joint
German/Austrian Conference on Artificial Intelligence,</i> number 2174 in Lecture Notes in Computer Science, pages 396-408, Vienna,
September 2001. Springer-Verlag.</span></p>

<p class="ref noindent" id="semweb01">[<a href="#rsemweb01">2</a>] T. Berners-Lee, J. Hendler, and O. Lassila. <span class="title">The
Semantic Web.</span> <span class="details">Scientific American, May 2001.</span></p>

<p class="ref noindent" id="rdfschema00">[<a href="#rrdfschema00">3</a>] D. Brickley and R. Guha (editors). <span class="title">Resource description
framework (rdf) schema specification 1.0.</span> <span class="details"><a href="http://www.w3.org/TR/2000/CR-rdf-schema-20000327/">http://www.w3.org/TR/2000/CR-rdf-schema-20000327/</a>,
March, 2000.</span></p>

<p class="ref noindent" id="oil00">[<a href="#roil00">4</a>] J. Broekstra, M. Klein, S. Decker, D. Fensel, and I. Horrocks. <span class=
"title">Adding formal semantics to the web: building on top of rdf schema.</span> <span class="details">In <i>ECDL Workshop on the
Semantic Web: Models, Architectures and Management,</i> 2000.</span></p>

<p class="ref noindent" id="daml-s">[<a href="#rdaml-s">5</a>] M. Burstein, J. Hobbs, O. Lassila, D. Martin, S. McIlraith, S. Narayanan, M.
Paolucci, T. Payne, K. Sycara, and H. Zeng. <span class="title">Daml service.</span> <span class="details"><a href=
"http://www.daml.org/services/daml-s/2001/05/">http://www.daml.org/services/daml-s/2001/05/</a>.</span></p>

<p class="ref noindent" id="owl">[<a href="#rowl">6</a>] M. Dean, D. Connolly, F. van Harmelen, J. Hendler, I. Horrocks, D. L.
McGuinness, P. F. Patel-Schneider, and L. A. Stein (editors). <span class="title">OWL Web Ontology Language 1.0 Reference.</span>
<span class="details"><a href="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a>, 2002.</span></p>

<p class="ref noindent" id="damlzeves03">[<a href="#rdamlzeves03">7</a>] J. S. Dong, C. H. Lee, Y. F. Li, and H. Wang. <span class="title">Verifying DAML+OIL and beyond in Z/EVES.</span>
<span class="details">In <i>Proceedings of 26<sup>th</sup> International Conference on Software
  Engineering (ICSE'04)</i>, Edinburgh, Scotland, May 2003. to appear.</span></p>

<p class="ref noindent" id="alloy03">[<a href="#ralloy03">8</a>] J. S. Dong, J. Sun and H. Wang. <span class="titie">Checking and Reasoning
about Semantic Web through Alloy.</span> <span class="details">In <i>Proceedings of Formal Methods Europe: FME'03.</i> volume 2805 of
<i>Lect. Notes in Comput. Sci.</i>, pages 796-814, Pisa, Italy, Sept. 2003. LNCS, Springer-Verlag.</span></p>

<p class="ref noindent" id="goguen92">[<a href="#rgoguen92">9</a>] J. A. Goguen and R. M. Burstall. <span class="title">Institutions: abstract
model theory for specification and programming.</span> <span class="details"><i>J. ACM,</i> 39(1):95-146, 1992.</span></p>

<p class="ref noindent" id="haarslev-practical">[<a href="#rhaarslev-practical">10</a>] V. Haarslev and R. M&ouml;ller.
<span class="title">Practical Reasoning in Racer with a Concrete Domain for Linear Inequations.</span>
<span class="details">In I. Horrocks and S. Tessaris, editors, <i>Proceedings of the
International Workshop on Description Logics (DL-2002),</i> Toulouse, France, Apr. 2002. CEUR-WS.</span></p>

<p class="ref noindent" id="racermanual">[<a href="#rracermanual">11</a>] V. Haarslev and R. M&ouml;ller. <span class="title"><i>RACER User's Guide and
Reference Manual: Version 1.7.6,</i></span> <span class="details">Dec.</span></p>

<p class="ref noindent" id="hoare:csp">[<a href="#rhoare:csp">12</a>] C. A. R. Hoare. <span class="title">Communicating Sequential
Processes</span>. <span class="details">Prentice-Hall International, 1985.</span></p>

<p class="ref noindent" id="fact98">[<a href="#rfact98">13</a>] I. Horrocks. <span class="title">The FaCT system.</span> <span class=
"details"><i>Tableaux'98, LNCS,</i> 1397:307-312, 1998.</span></p>

<p class="ref noindent" id="jac02">[<a href="#rjac02">14</a>] D. Jackson. <span class="title">Micromodels of
software: Lightweight modelling and analysis with Alloy.</span> <span class="details">Available: <a href=
"http://sdg.lcs.mit.edu/alloy/book.pdf">http://sdg.lcs.mit.edu/alloy/book.pdf</a> (an early version has been published in TOSEM Vol-11),
2002.</span></p>

<p class="ref noindent" id="alcoa00">[<a href="#ralcoa00">15</a>] D. Jackson, I. Schechter, and I. Shlyakhter. <span class="title">Alcoa: the
Alloy Constraint Analyzer.</span> <span class="details">In <i>The 22nd International Conference on Software Engineering
(ICSE'00),</i> pages 730-733, Limerick, Ireland, June 2000. ACM Press.</span></p>

<p class="ref noindent" id="lamb">[<a href="#rlamb">16</a>] P. Lambrix. <span class="title">Description Logics home page.</span>
<span class="details"><a href= "http://www.ida.liu.se/labs/iislab/people/patla/DL/index.html">http://www.ida.liu.se/labs/iislab/people/patla/DL/index.html</a>.</span></p>

<p class="ref noindent" id="dso02">[<a href="#rdso02">17</a>] C. H. Lee. <span class="title">Phase I Report for Plan Ontology.</span>
<span class="details">DSO National Labs, Singapore, 2002.</span></p>

<p class="ref noindent" id="rdf99">[<a href="#rrdf99">18</a>] O. Lassila and R. R. Swick (editors). <span class="title">Resource Description
Framework (RDF) Model and Syntax Specification.</span> <span class="details"><a href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/">http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/</a>,
Feb, 1999.</span></p>

<p class="ref noindent" id="PVS-CADE92">[<a href="#rPVS-CADE92">19</a>] S. Owre, J. M. Rushby, and N. Shankar. <span class="title">PVS: A prototype
verification system.</span> <span class="details">In D. Kapur, editor, <i>11th International Conference on Automated Deduction
(CADE)</i>, volume 607 of <i>Lecture Notes in Artificial Intelligence</i>, pages 748--752, Saratoga, NY, June 1992.
Springer-Verlag.</span></p>

<p class="ref noindent" id="zeves">[<a href="#rzeves">20</a>] M. Saaltink. <span class="title">The Z/EVES system.</span> <span class=
"details">In J. P. Bowen, M. G. Hinchey, and D. Till, editors, <i>ZUM'97: Z Formal Specification Notation,</i> volume 1212 of
<i>Lect. Notes in Comput. Sci.,</i> pages 72-85. Springer-Verlag, 1997.</span></p>

<p class="ref noindent" id="iswc02:364">[<a href="#riswc02:364">21</a>] M. Sintek and S. Decker. <span class="title"><tt>TRIPLE</tt> &ndash; A query,
inference, and transformation language for the semantic web.</span> <span class="details">In I. Horrocks and J. Hendler, editors, <i> The Semantic Web &ndash;
 ISWC 2002. Proceedings of the First International Semantic Web Conference</i>,
  volume 2348 of <i>Lect. Notes in Comput. Sci.</i>, pages 364--378, Sardinia, Italy, June 2002. Springer-Verlag.</span></p>

<p class="ref noindent" id="cwm">[<a href="#rcwm">22</a>] Tim Berners-Lee. <span class="title">cwm - a general purpose data processor for the semantic web.</span>
<span class="details"><a href="http://www.w3.org/2000/10/swap/doc/cwm">http://www.w3.org/2000/10/swap/doc/cwm</a>, 2004.</span></p>

<p class="ref noindent" id="daml01">[<a href="#rdaml01">23</a>] F. van Harmelen, P. F. Patel-Schneider, and I. Horrocks
(editors). <span class="title">Reference description of the DAML+OIL ontology markup language.</span> <span class=
"details">Contributors: T. Berners-Lee, D. Brickley, D. Connolly, M. Dean, S. Decker, P. Hayes, J. Heflin, J. Hendler, O. Lassila, D.
McGuinness, L. A. Stein, ..., March, 2001.</span></p>

<p class="ref noindent" id="DW:Z96">[<a href="#rDW:Z96">24</a>] J. Woodcock and J. Davies. <span class=
"title"><i>Using Z: Specification, Refinement, and Proof.</i></span> <span class="details">Prentice-Hall
International, 1996.</span></p>

<p class="ref noindent" id="xslt">[<a href="#rxslt">25</a>] World Wide Web Consortium (W3C). <span class="title">XSL Transformations (XSLT)
Version 1.0</span>. <span class="details"><a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a>,
1999.</span></p>

<p class="ref noindent" id="owl03">[<a href="#rowl03">26</a>] World Wide Web Consortium (W3C). <span class="title">OWL Web Ontology Language
Overview.</span> <span class="details"><a href="http://www.w3.org/TR/owl-features/">http://www.w3.org/TR/owl-features/</a>,
Mar. 2003.</span></p>

<p class="ref noindent" id="owl03req">[<a href="#rowl03req">27</a>] World Wide Web Consortium (W3C). <span class="title">Web Ontology Language
(OWL) Use Cases and Requirements.</span> <span class="details"><a href="http://www.w3.org/TR/webont-req/">http://www.w3.org/TR/webont-req/</a>,
Mar. 2003.</span></p>
</div>
<br />
<hr />
<h5>Footnotes</h5>
<dl>
<dt><a id="foot1">... Yuan Fang</a> <a href="#footnote1"><sup>*</sup></a></dt>
<dd>Author of correspondence: liyf@comp.nus.edu.sg</dd>
</dl>
</body>
<!--#exec cgi="/cgi-bin/pagecount"-->
</html>
